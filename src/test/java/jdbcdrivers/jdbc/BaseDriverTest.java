package jdbcdrivers.jdbc;

import static org.assertj.core.api.Assertions.assertThat;

import java.sql.Connection;
import java.sql.Driver;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.Properties;
import java.util.function.Supplier;

import com.informix.jdbc.IfxDriver;

import jdbcdrivers.databaseprotocol.vendor.informix.InformixJDBCDriver;
import jdbcdrivers.jdbc.PreparedStatements.PreparedInsert;
import jdbcdrivers.jdbc.PreparedStatements.PreparedSelect;
import jdbcdrivers.jdbc.PreparedStatements.StatementPreparer;
import jdbcdrivers.jdbc.utils.data.RowValueGenerator;
import jdbcdrivers.jdbc.utils.schema.Column;
import jdbcdrivers.jdbc.utils.schema.Table;
import jdbcdrivers.jdbc.utils.schema.TableSQL;
import jdbcdrivers.util.DriverUtil;

public abstract class BaseDriverTest {

    private static final boolean DEBUG = Boolean.FALSE;

    static final boolean UTILIZE_TEMP_TABLES = true;

    enum TestInformixDriver {

        OFFICIAL("official", IfxDriver::new),
        REIMPLEMENTED("reimplemented", InformixJDBCDriver::new);

        private final String commandLineArgumentValue;
        private final Supplier<Driver> driverInstantiator;

        static TestInformixDriver findFromCommanLineArgument(String commandLineArgument) {

            return DriverUtil.findExactlyOne(TestInformixDriver.values(), d -> d.commandLineArgumentValue.equals(commandLineArgument));
        }

        private TestInformixDriver(String commandLineArgumentValue, Supplier<Driver> driverInstantiator) {

            this.commandLineArgumentValue = Objects.requireNonNull(commandLineArgumentValue);
            this.driverInstantiator = Objects.requireNonNull(driverInstantiator);
        }

        Driver instantiateDriver() {

            return driverInstantiator.get();
        }
    }

    @FunctionalInterface
    interface RowsAdder {

        List<Object[]> addRows(Connection connection, Table table, int numRows, boolean returnAutoGeneratedKeys) throws SQLException;
    }

    static Connection connect(TestInformixDriver testInformixDriver, String url, String user, String password) throws SQLException {

        Objects.requireNonNull(testInformixDriver);
        Objects.requireNonNull(url);
        Objects.requireNonNull(user);

        final Properties properties = new Properties();

        properties.put("user", user);

        if (password != null) {

            properties.put("password", password);
        }

        return testInformixDriver.instantiateDriver().connect(url, properties);
    }

    @FunctionalInterface
    interface TableTestRunnable {

        void run(Connection connection, Table table) throws SQLException;
    }

    static void runForTable(Connection connection, Table table, TableTestRunnable tableTestRunnable) throws SQLException {

        Objects.requireNonNull(connection);
        Objects.requireNonNull(table);
        Objects.requireNonNull(tableTestRunnable);

        createTable(connection, table, UTILIZE_TEMP_TABLES);

        boolean ok = false;

        try {
            tableTestRunnable.run(connection, table);

            ok = true;
        }
        finally {

            System.out.println("dropping table '" + table.getName() + '\'');

            if (ok) {

                dropTable(connection, table);
            }

            System.out.println("dropped table '" + table.getName() + '\'');
        }
    }

    static void createTable(Connection connection, Table table, boolean tempTable) throws SQLException {

        Objects.requireNonNull(connection);
        Objects.requireNonNull(table);

        final String sql = TableSQL.makeCreateTableSQL(table, tempTable);

        if (DEBUG) {

            System.out.println("create table sql '" + sql + '\'');
        }

        executeSQL(connection, sql);

        connection.commit();
    }

    static void dropTable(Connection connection, Table table) throws SQLException {

        Objects.requireNonNull(connection);
        Objects.requireNonNull(table);

        final String sql = TableSQL.makeDropTableSQL(table);

        executeSQL(connection, sql);

        connection.commit();
    }

    static List<Object[]> insertRows(Connection connection, Table table, int numRows) throws SQLException {

        return insertRows(connection, table, numRows, Connection::prepareStatement);
    }

    static List<Object[]> insertRows(Connection connection, Table table, int numRows, boolean returnAutoGeneratedKeys) throws SQLException {

        return insertRows(connection, table, numRows, makeAutoGeneratedKeysStatementPreparer(returnAutoGeneratedKeys));
    }

    static List<Object[]> insertRows(Connection connection, Table table, int numRows, StatementPreparer statementPreparer) throws SQLException {

        return insertRows(connection, table, numRows, statementPreparer, s -> {

            final int updateCount = s.executeUpdate();

            if (updateCount != 1) {

                throw new IllegalStateException();
            }
        },
        null);
    }

    static List<Object[]> batchRows(Connection connection, Table table, int numRows, boolean returnAutoGeneratedKeys) throws SQLException {

        return batchRows(connection, table, numRows, makeAutoGeneratedKeysStatementPreparer(returnAutoGeneratedKeys));
    }

    static List<Object[]> batchRows(Connection connection, Table table, int numRows, StatementPreparer statementPreparer) throws SQLException {

        return insertRows(connection, table, numRows, statementPreparer, s -> s.addBatch(), (s, r) -> {

            final int[] updateCounts = s.executeBatch();

            if (updateCounts.length != r.size()) {

                throw new IllegalStateException();
            }

            for (int updateCount : updateCounts) {

                if (updateCount != 1) {

                    throw new IllegalStateException();
                }
            }
        });
    }

    private static StatementPreparer makeAutoGeneratedKeysStatementPreparer(boolean returnAutoGeneratedKeys) {

        final int autoGeneratedKeys = returnAutoGeneratedKeys ? Statement.RETURN_GENERATED_KEYS : Statement.NO_GENERATED_KEYS;

        return (c, s) -> c.prepareStatement(s, autoGeneratedKeys);
    }

    @FunctionalInterface
    interface RowAdder {

        void addRow(PreparedStatement preparedStatement) throws SQLException;
    }

    @FunctionalInterface
    interface BatchAdder {

        void addBatch(PreparedStatement preparedStatement, List<Object[]> rows) throws SQLException;
    }

    private static List<Object[]> insertRows(Connection connection, Table table, int numRows, StatementPreparer statementPreparer, RowAdder rowAdder, BatchAdder batchAdder)
            throws SQLException {

        Objects.requireNonNull(connection);
        Objects.requireNonNull(table);

        if (numRows < 0) {

            throw new IllegalArgumentException();
        }

        Objects.requireNonNull(rowAdder);

        final RowValueGenerator rowValueGenerator = new RowValueGenerator(table);

        rowValueGenerator.add(numRows);

        final List<Object[]> rows = rowValueGenerator.getRows();

        try (PreparedInsert preparedInsert = PreparedStatements.prepareInsert(connection, table, statementPreparer)) {

            if (DEBUG) {

                System.out.println("insert sql '" + preparedInsert.getSQL() + '\'');
            }

            insertRows(connection, preparedInsert.getPreparedStatement(), rows, rowAdder, batchAdder);
        }

        return rows;
    }

    private static void insertRows(Connection connection, PreparedStatement preparedStatement, List<Object[]> rows, RowAdder rowAdder, BatchAdder batchAdder) throws SQLException {

        Objects.requireNonNull(preparedStatement);
        Objects.requireNonNull(rows);
        Objects.requireNonNull(rowAdder);

//int counter = 0;

        for (Object[] row : rows) {

            if (DEBUG) {

                System.out.println("set parameters " + Arrays.toString(row));
            }

            setParameters(preparedStatement, 1, row);

            rowAdder.addRow(preparedStatement);
/*
++ counter;

if (counter % 1000 == 0) {

System.out.println("row commit " + connection.getAutoCommit() + ' ' + counter);
}
*/
//connection.commit();

        }

        if (batchAdder != null) {

            batchAdder.addBatch(preparedStatement, rows);
        }

//System.out.println("rows commit " + connection.getAutoCommit());
//        connection.commit();
    }

    static List<Object[]> selectAllRows(Connection connection, Table table) throws SQLException {

        Objects.requireNonNull(connection);
        Objects.requireNonNull(table);

        final List<Object[]> result = new ArrayList<>();

        try (PreparedSelect preparedSelect = PreparedStatements.prepareAllSelect(connection, table)) {

            if (DEBUG) {

                System.out.println("select all rows sql '" + preparedSelect + '\'');
            }

            try (ResultSet resultSet = preparedSelect.getPreparedStatement().executeQuery()) {

                retrieveResults(resultSet, table, result);
            }
        }

        return result;
    }

    private static void retrieveResults(ResultSet resultSet, Table table, List<Object[]> dst) throws SQLException {

        Objects.requireNonNull(resultSet);
        Objects.requireNonNull(table);
        Objects.requireNonNull(dst);

        final List<Column> columns = table.getColumns();

        while (resultSet.next()) {

            final Object[] row = retrieveRow(resultSet, columns);

            dst.add(row);
        }
    }

    static Object[] retrieveRow(ResultSet resultSet, Table table) throws SQLException {

        return retrieveRow(resultSet, table.getColumns());
    }

    private static Object[] retrieveRow(ResultSet resultSet, List<Column> columns) throws SQLException {

        final int numColumns = columns.size();

        final Object[] row = new Object[numColumns];

        for (int i = 0; i < numColumns; ++ i) {

            Object resultObject = resultSet.getObject(columns.get(i).getName());

            if (resultObject instanceof String) {

                resultObject = ((String)resultObject).trim();
            }

            row[i] = resultObject;
        }

        return row;
    }

    static void compareRows(List<Object[]> insertedRows, List<Object[]> selectedRows) {

        assertThat(insertedRows).hasSameSizeAs(selectedRows);

        final int numRows = insertedRows.size();

        for (int i = 0; i < numRows; ++ i) {

            checkRowsAreEqual(insertedRows.get(i), selectedRows.get(i));
        }
    }

    static void checkRowsAreEqual(Object[] row1, Object[] row2) {

        Objects.requireNonNull(row1);
        Objects.requireNonNull(row2);

        assertThat(row1).isEqualTo(row2);
    }

    private static void executeSQL(Connection connection, String sql) throws SQLException {

        Objects.requireNonNull(connection);
        Objects.requireNonNull(sql);

        try (Statement statement = connection.createStatement()) {

            statement.execute(sql);
        }
    }

    private static int setParameters(PreparedStatement preparedStatement, int startIndex, Object[] parameters) throws SQLException {

        Objects.requireNonNull(preparedStatement);

        if (startIndex < 1) {

            throw new IllegalArgumentException();
        }

        Objects.requireNonNull(parameters);

        final int numParameters = parameters.length;

        for (int i = 0; i < numParameters; ++ i) {

            preparedStatement.setObject(startIndex + i, parameters[i]);
        }

        return startIndex + numParameters;
    }

    @FunctionalInterface
    private interface Closer<T, E extends Exception> {

        void close(T toClose) throws E;
    }

    static void safeCloseAll(ResultSet ... resultSets) throws SQLException {

        safeCloseAll(ResultSet::close, resultSets);
    }

    @SafeVarargs
    private static <T, E extends Exception> void safeCloseAll(Closer<T, E> closer, T ... closeables) throws E {

        Objects.requireNonNull(closer);

        for (T closeable : closeables) {

            if (closeable != null) {

                closer.close(closeable);
            }
        }
    }
}
