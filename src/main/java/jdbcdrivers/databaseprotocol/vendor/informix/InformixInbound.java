package jdbcdrivers.databaseprotocol.vendor.informix;

import java.io.DataInput;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Collectors;

import jdbcdrivers.databaseprotocol.api.IRetrievedRows;
import jdbcdrivers.databaseprotocol.vendor.informix.InformixColumnPreparedStatement.PreparedColumn;
import jdbcdrivers.databaseprotocol.vendor.informix.InformixMessageType.Direction;
import jdbcdrivers.generic.api.ExecuteResult;
import jdbcdrivers.generic.api.GenericStatementExecutionOptions;
import jdbcdrivers.generic.api.GenericStatementExecutionOptions.AutoGeneratedKeys;
import jdbcdrivers.generic.exceptions.ProtocolErrorCodeException;
import jdbcdrivers.generic.exceptions.ProtocolErrorException;
import jdbcdrivers.util.DriverUtil;

/**
 * Helper methods for receiving messages from an Informix server.
 */
class InformixInbound extends InformixProtocolConstants {

    private static final boolean DEBUG = Boolean.FALSE;

    /**
     * Values from response to the initial setup message.
     */
    static final class InitialSetupReponse {

        private final String ieeei;
        private final String serverInformation;
        private final String serialType;
        private final String serverName;

        private InitialSetupReponse(String ieeei, String serverInformation, String serialType, String serverName) {

            this.ieeei = Objects.requireNonNull(ieeei);
            this.serverInformation = Objects.requireNonNull(serverInformation);
            this.serialType = Objects.requireNonNull(serialType);
            this.serverName = Objects.requireNonNull(serverName);
        }

        String getIEEEI() {
            return ieeei;
        }

        String getServerInformation() {
            return serverInformation;
        }

        String getSerialType() {
            return serialType;
        }

        String getServerName() {
            return serverName;
        }
    }

    static InitialSetupReponse receiveInitialSetupReponse(DataInput dataInput, int messageLength) throws ProtocolErrorException, IOException {

        int bytesTokip = 12;

        dataInput.skipBytes(bytesTokip);

        int skipped = bytesTokip;

        final String ieeei = receiveLengthZeroTerminatedASCIIString(dataInput);

        skipped += ieeei.length() + 3;

//        skipped += skipZeroTerminatedASCIIString(dataInput);

        bytesTokip = 14;

        dataInput.skipBytes(bytesTokip);

        skipped += bytesTokip;

        final String serverInfo = receiveLengthZeroTerminatedASCIIString(dataInput);

        skipped += serverInfo.length() + 3;

        final String serialType = receiveLengthZeroTerminatedASCIIString(dataInput);

        skipped += serialType.length() + 3;

        final String serverName = receiveLengthZeroTerminatedASCIIString(dataInput);

        skipped += serverName.length() + 3;

System.out.format("receive entire message skipped=0x%04x '%s' '%s' '%s' '%s'\n", skipped, ieeei, serverInfo, serialType, serverName);

        dataInput.skipBytes(messageLength - skipped - 4);

        if (dataInput.readUnsignedShort() != 0x007F) {

            throw new ProtocolErrorException();
        }
//        receiveTerminator(dataInput);

//        receiveEntireMessage(dataInput, messageLength - skipped);

        return new InitialSetupReponse(ieeei, serverInfo, serialType, serverName);
    }

    static void receiveUnknown1(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(12);

        receiveTerminator(dataInput);
    }
/*
    static void receiveUnknown2(DataInput dataInput) throws ProtocolErrorException, IOException {

        receiveTerminator(dataInput);
    }
*/
    static void receivePropertiesReponse(DataInput dataInput) throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        receiveTerminatorOrErrorResponse(dataInput);
//        receiveTerminator(dataInput);
    }

    static void receiveSelectDatabaseReponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(24);

        receiveTerminator(dataInput);
    }

    static void receiveSetIsolationReponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(42);

        receiveTerminator(dataInput);
    }

    static void receiveIFXCReponse(DataInput dataInput) throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        receiveTerminatorOrErrorResponse(dataInput);
    }

    static void receiveRetrieveCharsetResponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(4);

        receiveLengthASCIIString(dataInput);

        dataInput.skipBytes(26);

        receiveTerminator(dataInput);
    }

    static void receiveAutoCommitReponse(DataInput dataInput) throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        receiveTerminatorOrErrorResponse(dataInput);
    }

    @Deprecated // different result types
    static ExecuteResult receiveExecuteSQLReponse(DataInput dataInput) throws ProtocolErrorException, IOException {

//        final int messageLength = receiveMessageLength(dataInput);

//        dataInput.skipBytes(messageLength - 6);
//        dataInput.skipBytes(messageLength - 5);

        dataInput.skipBytes(42);

//System.out.format("message length 0x%04x\n", messageLength);

        final ExecuteResult result = new ExecuteResult();

/*
        final InformixResultType resultType = receiveResultType(dataInput);

        if (resultType != InformixResultType.EXECUTE_SQL) {

            throw new ProtocolErrorException();
        }
*/

        receiveTerminator(dataInput);

        return result;
    }

    private static final class PrepareReponseColumn {

        private final int indexIntoColumnNames;
        private final int indexIntoRow;
        private final InformixDataType informixDataType;
        private final int numRowBytesForColumn;

        PrepareReponseColumn(int indexIntoColumnNames, int indexIntoRow, InformixDataType informixDataType, int numRowBytesForColumn) {

            this.indexIntoColumnNames = indexIntoColumnNames;
            this.indexIntoRow = indexIntoRow;
            this.informixDataType = informixDataType;
            this.numRowBytesForColumn = numRowBytesForColumn;
        }
    }

    static InformixPreparedStatement receivePrepareStatementResponse(DataInput dataInput, GenericStatementExecutionOptions statementParameters) throws ProtocolErrorException, IOException {

        final InformixResultType resultType = receiveResultType(dataInput);

        final int preparedStatementIdentifier = receivePreparedStatementIdentifier(dataInput);

        final InformixPreparedStatement result;

        dataInput.skipBytes(2);

        switch (resultType) {

        case SELECT:

            result = receiveColumnPreparedStatement(dataInput, preparedStatementIdentifier, statementParameters);

            dataInput.skipBytes(26);

            receiveTerminator(dataInput);
            break;

        case INSERT_UPDATE:

            result = receiveColumnPreparedStatement(dataInput, preparedStatementIdentifier, statementParameters);

            dataInput.skipBytes(statementParameters.getAutoGeneratedKeys() == AutoGeneratedKeys.RETURN_GENERATED_KEYS ? 98 : 46);

            receiveTerminator(dataInput);
            break;

        default:
            throw new ProtocolErrorException();
        }

        return result;
    }

    private static InformixColumnPreparedStatement receiveColumnPreparedStatement(DataInput dataInput, int preparedStatementIdentifier,
            GenericStatementExecutionOptions statementExecutionOptions) throws ProtocolErrorException, IOException {

        final int maxRowSize = dataInput.readInt();

        if (DEBUG) {

            System.out.format("max row size 0x%04x\n", maxRowSize);
        }

        final int numColumns = receiveNumColumns(dataInput);

        if (DEBUG) {

            System.out.println("num columns " + numColumns);
        }

        dataInput.skipBytes(2);

        final List<PreparedColumn> columns = receiveColumnData(dataInput, numColumns);

        return new InformixColumnPreparedStatement(preparedStatementIdentifier, statementExecutionOptions, maxRowSize, columns);
    }

    static void receiveExecuteBatchesResponse(DataInput dataInput, InformixColumnPreparedStatement preparedStatement) throws ProtocolErrorException, IOException {

        final int numColumns = dataInput.readUnsignedShort();

        if (numColumns != preparedStatement.getNumColumns()) {

            throw new ProtocolErrorException();
        }

        dataInput.skipBytes(2);

        for (int i = 0; i < numColumns; ++ i) {

            dataInput.skipBytes(22);
        }

        receiveTerminator(dataInput);
    }

    static void receiveValuesForPreparedReponse(DataInput dataInput, GenericStatementExecutionOptions statementParameters, int[] updateCountsDst, int[] generatedKeysDst)
            throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        int responseCounter = 0;

        boolean done = false;

        do {
            final InformixMessageType messageType = receiveMessageType(dataInput);

            if (DEBUG) {

                System.out.println("receive values message type " + messageType);
            }

            switch (messageType) {

            case ERROR:

                final int errorCode = receiveErrorReponse(dataInput);

                throw new ProtocolErrorCodeException(errorCode);

            case TERMINATOR:

                done = true;
                break;

            case RESULT:

                updateCountsDst[responseCounter] = receiveValuesForPreparedReponse(dataInput);

                ++ responseCounter;
                break;

            case AUTO_GENERATED_KEY:

                final int generatedKey = receiveAutoGeneratedKey(dataInput);

                generatedKeysDst[responseCounter] = generatedKey;

                if (receiveMessageType(dataInput) != InformixMessageType.VALUES_FOR_PREPARED_RESPONSE) {

                    throw new ProtocolErrorException();
                }

                updateCountsDst[responseCounter] = receiveValuesForPreparedReponse(dataInput);

                ++ responseCounter;
                break;

            default:
                throw new ProtocolErrorException();
            }
        }
        while (!done);
    }

    private static int receiveAutoGeneratedKey(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(4);

        final int keyLength = dataInput.readUnsignedShort();

        if (keyLength != 4) {

            throw new ProtocolErrorException();
        }

        return dataInput.readInt();
    }

    private static int receiveValuesForPreparedReponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(44);

//        receiveTerminator(dataInput);

        return 1;
    }

    private static List<PreparedColumn> receiveColumnData(DataInput dataInput, int numColumns) throws ProtocolErrorException, IOException {

        final int numColumnNameBytes = dataInput.readUnsignedShort();

        final PrepareReponseColumn[] prepareReponseColumns = receivePreparedStatementResponseColumns(dataInput, numColumns);

        final Map<Integer, PrepareReponseColumn> prepareResponseColumByColumnNameIndex = Arrays.stream(prepareReponseColumns)
                .collect(Collectors.toUnmodifiableMap(c -> c.indexIntoColumnNames, Function.identity()));

        final List<PreparedColumn> columns = receivePreparedStatementColumnNames(dataInput, numColumns, numColumnNameBytes,
                prepareResponseColumByColumnNameIndex);

        receiveOnePad(dataInput, numColumnNameBytes);

        return columns;
    }

    static void receiveExecutePreparedQueryResponse(DataInput dataInput) throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        receiveTerminatorOrErrorResponse(dataInput);
    }

    static void receiveClosePreparedStatementResponse(DataInput dataInput) throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        receiveTerminatorOrErrorResponse(dataInput);
    }

    @Deprecated
    static void receivePreparedOperationResponse(DataInput dataInput) throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        receiveTerminatorOrErrorResponse(dataInput);
    }

    static void receiveBeginReponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(6);

        receiveTerminator(dataInput);
    }

    static void receivePreparedOperation0x07Reponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(24);

        receiveTerminator(dataInput);
    }

    static void receiveCommitReponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        dataInput.skipBytes(6);

        receiveTerminator(dataInput);
    }

    static void receiveResultRows(DataInput dataInput, byte[] dst, int maxRowsToReceive, int maxBytesPerRow, IRetrievedRows retrievedRows)
            throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        Objects.requireNonNull(dataInput);
        Objects.requireNonNull(dst);

        if (maxRowsToReceive < 1) {

            throw new IllegalArgumentException();
        }

        final int dstLength = dst.length;

        if (DEBUG) {

            System.out.println("receive result rows dstLength=" + dstLength + " maxBytesPerRow=" + maxBytesPerRow);
        }

        if (dstLength < maxBytesPerRow) {

            throw new IllegalArgumentException();
        }

        boolean done = false;

        int dstIndex = 0;

        int remainingRows = maxRowsToReceive;

        do {
            final InformixMessageType messageType = receiveMessageType(dataInput);

            if (DEBUG) {

                System.out.println("receive result rows messageType=" + messageType);
            }

            switch (messageType) {

            case ERROR:

                final int errorCode = receiveErrorReponse(dataInput);

                throw new ProtocolErrorCodeException(errorCode);

            case QUERY_RESPONSE:
            case RESULT_ROW:

                dataInput.skipBytes(2);

                final int rowLength = dataInput.readInt();

                if (rowLength < 0) {

                    throw new ProtocolErrorException();
                }

                retrievedRows.addRow(rowLength);

                dataInput.readFully(dst, dstIndex, rowLength);

                dstIndex += rowLength;

                -- remainingRows;

                if (DEBUG) {

                    System.out.println("retrieve row dstLength=" + dstLength + " dstIndex=" + dstIndex + " rowLength=" + rowLength + " maxBytesPerRow=" + maxBytesPerRow);
                }

                if (dstLength - dstIndex < maxBytesPerRow) {

                    if (DriverUtil.padToTwoBytes(maxBytesPerRow)) {

                        dataInput.skipBytes(1);
                    }

                    done = true;
                }
                break;

            case RESPONSE_STATUS:

                if (Boolean.FALSE) {

                    throw new UnsupportedOperationException();
                }

                dataInput.skipBytes(24);

                receiveTerminator(dataInput);

                done = true;
                break;

            default:
                throw new ProtocolErrorException();
            }

            if (remainingRows == 0) {

                done = true;
            }
        }
        while (!done);

        if (DEBUG) {

            System.out.println("exit receive result rows dstLength=" + dstLength + " maxBytesPerRow=" + maxBytesPerRow);
        }
    }

    static int receiveErrorReponse(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int errorCode = dataInput.readShort();
        final int errorCode2 = dataInput.readShort();

System.out.println("received error code " + errorCode + ' ' + errorCode2);

        dataInput.skipBytes(2);

        final int flag = dataInput.readUnsignedShort();

        if (flag == 0x0018) {

            final String errorMessage = receiveLengthASCIIString(dataInput);

System.out.println("error message '" + errorMessage + '\'');
        }
        else {
            dataInput.skipBytes(2);
        }

        receiveTerminator(dataInput);

        return errorCode;
    }

    static void receiveTerminatorOrErrorResponse(DataInput dataInput) throws ProtocolErrorException, ProtocolErrorCodeException, IOException {

        Objects.requireNonNull(dataInput);

        final int code = dataInput.readUnsignedShort();

        if (code == InformixProtocolConstants.TERMINATOR) {

        }
        else if (code == InformixMessageType.ERROR.getCode()) {

            final int errorCode = receiveErrorReponse(dataInput);

            throw new ProtocolErrorCodeException(errorCode);
        }
        else {
            throw new ProtocolErrorException();
        }
    }

    private static void receiveOnePad(DataInput dataInput, int number) throws IOException {

        if ((number & 0x00000001) != 0) {

            dataInput.readByte();
        }
    }

    private static PrepareReponseColumn[] receivePreparedStatementResponseColumns(DataInput dataInput, int numColumns) throws ProtocolErrorException, IOException {

        if (DEBUG) {

            System.out.println("receive prepared statement response columns " + numColumns);
        }

        final PrepareReponseColumn[] prepareReponseColumns = new PrepareReponseColumn[numColumns];

        int totalBytesForRow = 0;

        for (int i = 0; i < numColumns; ++ i) {

            if (DEBUG) {

                System.out.println("response column " + i);
            }

            dataInput.skipBytes(2);

            final int indexIntoColumnNames = dataInput.readUnsignedShort();

            if (DEBUG) {

                System.out.format("index into column names 0x%04x\n", indexIntoColumnNames);
            }

            final int indexIntoRow = dataInput.readInt();

            if (DEBUG) {

                System.out.format("index into row 0x%04x\n", indexIntoRow);
            }

            if (indexIntoRow != totalBytesForRow) {

                throw new ProtocolErrorException();
            }

            final InformixDataType informixDataType = receiveDataType(dataInput);

            if (DEBUG) {

                System.out.println("data type " + informixDataType);
            }

            dataInput.skipBytes(18);

            final int numRowBytesForColumn = dataInput.readUnsignedShort();

            if (DEBUG) {

                System.out.format("num row bytes for column 0x%04x\n", numRowBytesForColumn);
            }

            totalBytesForRow += numRowBytesForColumn;

            if (informixDataType.hasResponseColumnAdditionalLengthBytes()) {

                totalBytesForRow += informixDataType.getNumResponseColumnAdditionalLengthBytes();
            }

            prepareReponseColumns[i] = new PrepareReponseColumn(indexIntoColumnNames, indexIntoRow, informixDataType, numRowBytesForColumn);
        }

        return prepareReponseColumns;
    }

    private static List<PreparedColumn> receivePreparedStatementColumnNames(DataInput dataInput, int numColumns, int numColumnNameBytes,
            Map<Integer, PrepareReponseColumn> prepareResponseColumByColumnNameIndex) throws ProtocolErrorException, IOException {

        final List<PreparedColumn> columns = new ArrayList<>(numColumns);

        int columnNamesIndex = 0;

        for (int i = 0; i < numColumns; ++ i) {

            final String columnName = receiveZeroTerminatedASCIIString(dataInput);

            final PrepareReponseColumn prepareReponseColumn = prepareResponseColumByColumnNameIndex.get(columnNamesIndex);

            if (prepareReponseColumn == null) {

                throw new ProtocolErrorException();
            }

            final PreparedColumn column = new PreparedColumn(columnName, prepareReponseColumn.informixDataType, prepareReponseColumn.indexIntoRow,
                    prepareReponseColumn.indexIntoRow /* + InformixProtocolConstants.NUM_ROW_LENGTH_BYTES */, prepareReponseColumn.numRowBytesForColumn);

            columns.add(column);

            columnNamesIndex += columnName.length() + 1;

            if (columnNamesIndex > numColumnNameBytes) {

                throw new ProtocolErrorException();
            }
        }

        return columns;
    }

    private static int receivePreparedStatementIdentifier(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int identifier = dataInput.readUnsignedShort();

        if (!InformixChecks.isValidPreparedStatementIdentifier(identifier)) {

            throw new ProtocolErrorException();
        }

        return identifier;
    }

    private static int receiveNumColumns(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int numColumns = dataInput.readUnsignedShort();

        if (!InformixChecks.isValidNumColumns(numColumns)) {

            throw new ProtocolErrorException();
        }

        return numColumns;
    }

    private static InformixMessageType receiveMessageType(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int messageTypeCode = dataInput.readUnsignedShort();

        final InformixMessageType messageType = InformixMessageType.fromCodeOrNull(messageTypeCode);

        if (messageType == null) {

System.out.format("unknown message type 0x%02x\n", messageTypeCode);

            throw new ProtocolErrorException();
        }

        final Direction direction = messageType.getDirection();

        if (direction != Direction.INBOUND && direction != Direction.BOTH) {

System.out.println("non inbound message type " + messageType);

            throw new ProtocolErrorException();
        }

        return messageType;
    }

    private static InformixResultType receiveResultType(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int resultTypeCode = dataInput.readUnsignedShort();

        final InformixResultType resultType = InformixResultType.fromCodeOrNull(resultTypeCode);

        if (resultType == null) {

            throw new ProtocolErrorException();
        }

        return resultType;
    }

    private static InformixDataType receiveDataType(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int dataTypeCode = dataInput.readUnsignedShort();

        final InformixDataType informixDataType = InformixDataType.fromCodeOrNull(dataTypeCode & 0x00FF);

        if (informixDataType == null) {

System.out.format("unknown data type 0x%04x\n", dataTypeCode);

            throw new ProtocolErrorException();
        }

        return informixDataType;
    }

    private static void receiveTerminator(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int terminator = dataInput.readUnsignedShort();

        if (terminator != TERMINATOR) {

System.out.format("wrong terminator 0x%04x\n", terminator);

            throw new ProtocolErrorException();
        }
    }

    static int receiveMessageLength(DataInput dataInput) throws IOException {

        return dataInput.readUnsignedShort();
    }

    private static String receiveLengthZeroTerminatedASCIIString(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int stringLength = dataInput.readUnsignedShort();

        return receiveZeroTerminatedASCIIString(dataInput, stringLength - 1);
    }

    private static final int UNKNOWN_LENGTH = -1;

    private static String receiveZeroTerminatedASCIIString(DataInput dataInput) throws ProtocolErrorException, IOException {

        return receiveZeroTerminatedASCIIString(dataInput, UNKNOWN_LENGTH);
    }

    private static String receiveZeroTerminatedASCIIString(DataInput dataInput, int stringLength) throws ProtocolErrorException, IOException {

        final StringBuilder sb = new StringBuilder(stringLength != UNKNOWN_LENGTH ? stringLength : 1000);

        for (;;) {

            final int character = dataInput.readByte();

            if (character < 0) {

                throw new ProtocolErrorException();
            }

            if (character == 0) {

                break;
            }

            sb.append((char)character);
        }

        if (stringLength != UNKNOWN_LENGTH && sb.length() != stringLength) {

System.out.println("sb length=" + sb.length() + " stringLength=" + stringLength + " sb='" + sb + '\'');

            throw new ProtocolErrorException();
        }

        return sb.toString();
    }

    private static String receiveLengthASCIIString(DataInput dataInput) throws ProtocolErrorException, IOException {

        final int stringLength = dataInput.readUnsignedShort();

        final StringBuilder sb = new StringBuilder(stringLength);

        for (int i = 0; i < stringLength; ++ i) {

            final int character = dataInput.readByte();

            if (character <= 0) {

                throw new ProtocolErrorException();
            }

            sb.append((char)character);
        }

        return sb.toString();
    }
}
