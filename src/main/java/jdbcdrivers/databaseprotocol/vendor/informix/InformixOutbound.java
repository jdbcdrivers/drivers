package jdbcdrivers.databaseprotocol.vendor.informix;

import java.io.DataOutput;
import java.io.IOException;
import java.net.InetAddress;
import java.net.URI;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Properties;

import jdbcdrivers.databaseprotocol.api.IGenericPreparedStatementParameterGetters;
import jdbcdrivers.databaseprotocol.vendor.informix.InformixColumnPreparedStatement.PreparedColumn;
import jdbcdrivers.databaseprotocol.vendor.informix.InformixMessageType.Direction;
import jdbcdrivers.generic.api.GenericStatementExecutionOptions;
import jdbcdrivers.generic.api.GenericStatementExecutionOptions.AutoGeneratedKeys;
import jdbcdrivers.generic.util.StringEncoder;
import jdbcdrivers.util.DriverUtil;

/**
 * Helper methods for sending messages to an Informix server.
 */
class InformixOutbound extends InformixProtocolConstants {

    private static final boolean DEBUG = Boolean.FALSE;

    private static final byte[] INITIAL_HEADER = new byte[] {
            0x01, 0x3C, 0x00, 0x00, 0x00, 0x64, 0x00, 0x65, 0x00, 0x00, 0x00, 0x3d
    };

    private static final byte[] INITIAL_ADDITIONAL1 = new byte[] {
            0x00, 'l', 's', 'q', 'l', 'e', 'x', 'e', 'c', 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x39, 0x2E, 0x32, 0x38, 0x30, 0x00
    };

    private static final byte[] INITIAL_ADDITIONAL2 = new byte[] {
            0x00, 0x00, 0x01, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
    };

    private static final byte[] INITIAL_ADDITIONAL3 = new byte[] {
            0x6F, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D
    };

    private static final byte[] INITIAL_ADDITIONAL4 = new byte[] {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x68, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x6A
    };

    private static final byte[] INITIAL_ADDITIONAL5 = new byte[] {
            0x00, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x00, 0x00, 0x00, 0x01
    };

    private static final byte[] INITIAL_ADDITIONAL6 = new byte[] {
            0x00, 0x74, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    static void sendInitialSetup(DataOutput dataOutput, URI uri, Properties properties) throws IOException {

        final String user = properties.getProperty("user");

        if (user == null) {

            throw new IllegalArgumentException();
        }

        final String password = properties.getProperty("password");

        if (password == null) {

            throw new IllegalArgumentException();
        }

        dataOutput.write(INITIAL_HEADER);

        writeLengthZeroTerminatedASCIIString(dataOutput, "IEEEM");

        dataOutput.write(INITIAL_ADDITIONAL1);

        writeLengthZeroTerminatedASCIIString(dataOutput, "RDS#R000000");

        writeLengthZeroTerminatedASCIIString(dataOutput, "sqli");

        dataOutput.write(INITIAL_ADDITIONAL2);

        writeLengthZeroTerminatedASCIIString(dataOutput, user);

        writeLengthZeroTerminatedASCIIString(dataOutput, password);

        dataOutput.write(INITIAL_ADDITIONAL3);

        DriverUtil.writeASCIIStringCharacters(dataOutput, "tlitcp");

        dataOutput.write(INITIAL_ADDITIONAL4);

        final int numProperties = 6;

        dataOutput.writeShort(numProperties);

        writeKeyValueZeroTerminated(dataOutput, "DBPATH",".");
        writeKeyValueZeroTerminated(dataOutput, "CLIENT_LOCALE", "en_US.8859-1");
        writeKeyValueZeroTerminated(dataOutput, "CLNT_PAM_CAPABLE", "1");
        writeKeyValueZeroTerminated(dataOutput, "DBDATE", "Y4MD-");
        writeKeyValueZeroTerminated(dataOutput, "IFX_UPDDESC", "1");
        writeKeyValueZeroTerminated(dataOutput, "NODEFDAC", "no");

        dataOutput.write(INITIAL_ADDITIONAL5);

        final String hostName = InetAddress.getLocalHost().getHostName();

        writeLengthZeroTerminatedASCIIString(dataOutput, hostName);

        dataOutput.writeShort(0);

        // current working directory
        writeLengthZeroTerminatedASCIIString(dataOutput, "/current_working_directory");

        dataOutput.write(INITIAL_ADDITIONAL6);

        final String threadInformation = "Thread[id:1, name:main, path:/home/user/.m2/repository/com/ibm/informix/jdbc/4.50.11/jdbc-4.50.11.jar]";

        writeLengthZeroTerminatedASCIIString(dataOutput, threadInformation);

        dataOutput.writeShort(0x007F);
    }

    private static final byte[] UNKNOWN1 = new byte[] {
            0x00, 0x7E, 0x00, 0x08, DriverUtil.unsignedIntToByte(0xFF), DriverUtil.unsignedIntToByte(0xFC), 0x7F, DriverUtil.unsignedIntToByte(0xFC), 0x3C,
            DriverUtil.unsignedIntToByte(0x8C), DriverUtil.unsignedIntToByte(0xAA), DriverUtil.unsignedIntToByte(0x97)
    };

    static void sendUnknown1(DataOutput dataOutput) throws IOException {

        dataOutput.write(UNKNOWN1);

        writeTerminator(dataOutput);
    }

    private static final byte[] PROPERTIES_HEADER = new byte[] {
            0x00, 0x06, 0x00, 0x26, 0x00, 0x0C, 0x00, 0x04
    };

    private static final byte[] PROPERTIES_ADDITIONAL = new byte[] {
            0x00, 0x00, 0x00, 0x00
    };

    static void sendProperties(DataOutput dataOutput) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.PROPERTIES);

        dataOutput.write(PROPERTIES_HEADER);

        writeKeyValue(dataOutput, "DBTEMP", "/tmp");
        writeKeyValue(dataOutput, "SUBQCACHESZ", "10");

        dataOutput.write(PROPERTIES_ADDITIONAL);

        writeTerminator(dataOutput);
    }

    static void sendSelectDatabase(DataOutput dataOutput, String databaseName) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.SELECT_DATABASE);

        writeLengthASCIIString(dataOutput, databaseName);

        dataOutput.writeShort(0x0000);

        writeTerminator(dataOutput);
    }

    static void sendSetIsolation(DataOutput dataOutput, String sql) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.SET_ISOLATION);

        dataOutput.writeInt(0x0000);

        writeLengthZeroTerminatedASCIIString(dataOutput, sql);

        dataOutput.writeShort(0x0016);
        dataOutput.writeShort(0x0007);
        dataOutput.writeShort(0x000B);

        writeTerminator(dataOutput);
    }

    static void sendIFXC(DataOutput dataOutput, int preparedStatementIdentifier, int parameter) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        dataOutput.writeShort(preparedStatementIdentifier);

        writePreparedOperationType(dataOutput, InformixOperationType.IFXC_0x3);

        writeLengthASCIIString(dataOutput, String.format("_ifxc%013d", parameter));

        dataOutput.writeShort(0x0006);

        writeTerminator(dataOutput);
    }

    private static final byte[] RETRIEVE_CHARSET_ADDITIONAL = new byte[] {
            0x00, 0x01, 0x00, 0x01, 0x00, 0x0D, 0x00, 0x00, 0x00, DriverUtil.unsignedIntToByte(0x80), 0x00, 0x09, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00
    };

    static void sendRetrieveCharset(DataOutput dataOutput) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        dataOutput.writeShort(0x0000);

        writePreparedOperationType(dataOutput, InformixOperationType.EXECUTE_QUERY);

        dataOutput.write(RETRIEVE_CHARSET_ADDITIONAL);

        writeTerminator(dataOutput);
    }

    static void sendAutoCommitOff(DataOutput dataOutput) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        dataOutput.writeShort(0x0000);

        writePreparedOperationType(dataOutput, InformixOperationType.SET_AUTO_COMMIT_OFF);

        writeTerminator(dataOutput);
    }

    static void sendExecutePreparedQuery(DataOutput dataOutput, InformixColumnPreparedStatement preparedStatement,
            IGenericPreparedStatementParameterGetters preparedStatementParameters, StringEncoder stringEncoder) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        writePreparedStatementIdentifier(dataOutput, preparedStatement);

        writePreparedOperationType(dataOutput, InformixOperationType.EXECUTE_QUERY);

        dataOutput.writeShort(0x0001);

        final List<PreparedColumn> columns = preparedStatement.getColumns();

        dataOutput.writeShort(columns.size());

        for (PreparedColumn column : columns) {

            writeInformixDataType(dataOutput, column.getDataType());

            dataOutput.writeShort(0x0000);

            dataOutput.writeShort(column.getNumRowBytes());
        }

        writePreparedStatementIdentifier(dataOutput, preparedStatement);

        dataOutput.writeShort(0x0000);
        dataOutput.writeShort(0x1000);
        dataOutput.writeShort(0x0000);

        writeTerminator(dataOutput);
    }

    static void sendExecuteBatches(DataOutput dataOutput, InformixColumnPreparedStatement preparedStatement) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        writePreparedStatementIdentifier(dataOutput, preparedStatement);

        writePreparedOperationType(dataOutput, InformixOperationType.EXECUTE_BATCH);

        writeTerminator(dataOutput);
    }

    static void sendUpdateBatches(DataOutput dataOutput, InformixColumnPreparedStatement preparedStatement,
            Collection<? extends IGenericPreparedStatementParameterGetters> batches, StringEncoder stringEncoder) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        writePreparedStatementIdentifier(dataOutput, preparedStatement);

        for (IGenericPreparedStatementParameterGetters preparedStatementParameters : batches) {

            writePreparedOperationType(dataOutput, InformixOperationType.INSERT);

            sendUpdateValuesRow(dataOutput, preparedStatement, preparedStatementParameters, stringEncoder);
        }

        writeTerminator(dataOutput);
    }

    static void sendUpdateValues(DataOutput dataOutput, InformixColumnPreparedStatement preparedStatement, IGenericPreparedStatementParameterGetters preparedStatementParameters,
            StringEncoder stringEncoder) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        writePreparedStatementIdentifier(dataOutput, preparedStatement);

        writePreparedOperationType(dataOutput, InformixOperationType.INSERT);

        sendUpdateValuesRow(dataOutput, preparedStatement, preparedStatementParameters, stringEncoder);

        writeTerminator(dataOutput);
    }

    private static void sendUpdateValuesRow(DataOutput dataOutput, InformixColumnPreparedStatement preparedStatement,
            IGenericPreparedStatementParameterGetters preparedStatementParameters, StringEncoder stringEncoder) throws IOException {

        final List<PreparedColumn> columns = preparedStatement.getColumns();

        final int numColumns = columns.size();

        if (numColumns != preparedStatementParameters.getNumParameters()) {

            throw new IllegalArgumentException();
        }

        dataOutput.writeShort(numColumns);

        for (int i = 0; i < numColumns; ++ i) {

            final PreparedColumn column = columns.get(i);

            final InformixDataType informixDataType = column.getDataType();

            writeInformixDataType(dataOutput, informixDataType);

            dataOutput.writeShort(0x0000);

            if (preparedStatementParameters.isNull(i)) {

                throw new UnsupportedOperationException();
            }
            else {
                if (informixDataType.isString()) {

                    final int numRowBytesForColumn = column.getNumRowBytes();

                    dataOutput.writeShort(numRowBytesForColumn);

                    final String string = preparedStatementParameters.getString(i);

                    final int encodedLength = stringEncoder.encode(string);

                    if (DEBUG) {

                        System.out.println("encoded length '" + string + "' " + encodedLength);
                    }

                    if (encodedLength + 1 > numRowBytesForColumn) {

                        throw new IllegalArgumentException();
                    }

                    dataOutput.writeShort(encodedLength);

                    stringEncoder.writeEncoded(dataOutput);

                    // write zero terminator
                    dataOutput.writeByte(0);
                }
                else {
                    sendData(dataOutput, preparedStatementParameters, i, informixDataType);
                }
            }
        }

        dataOutput.writeShort(0x0007);
    }

    private static void sendData(DataOutput dataOutput, IGenericPreparedStatementParameterGetters parameterGetters, int index, InformixDataType informixDataType) throws IOException {

        switch (informixDataType) {

        case INTEGER:
        case SERIAL:

            dataOutput.writeShort(0x0A00);

            dataOutput.writeInt(parameterGetters.getInt(index));
            break;

        default:
            throw new UnsupportedOperationException();
        }
    }

    static void sendClosePreparedStatement(DataOutput dataOutput, InformixPreparedStatement preparedStatement) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        writePreparedStatementIdentifier(dataOutput, preparedStatement);

        writePreparedOperationType(dataOutput, InformixOperationType.OP_0x0B);

        writeTerminator(dataOutput);
    }

    static void sendExecuteSQL(DataOutput dataOutput, String sql) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.EXECUTE_SQL);

        writeExecuteType(dataOutput, InformixExecuteType.DIRECT);

        dataOutput.writeShort(0x0000);

        final int bytesWritten = writeLengthASCIIString(dataOutput, sql);

        writeOnePad(dataOutput, bytesWritten);

        dataOutput.writeShort(0x0016);

        dataOutput.writeShort(0x0031);

        writeTerminator(dataOutput);
    }

    @Deprecated // count escaped question marks
    static void sendPrepareStatement(DataOutput dataOutput, String sql, GenericStatementExecutionOptions statementParameters, int numSQLParameters) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.EXECUTE_SQL);

//        writeExecuteType(dataOutput, ExecuteType.PREPARED_STATEMENT);

        dataOutput.writeShort(numSQLParameters);

        dataOutput.writeShort(0x0000);

        final int bytesWritten = writeLengthASCIIString(dataOutput, sql);

        writeOnePad(dataOutput, bytesWritten);

        if (statementParameters.getAutoGeneratedKeys() == AutoGeneratedKeys.RETURN_GENERATED_KEYS) {

            dataOutput.writeShort(0x0086);

            dataOutput.writeShort(0x0001);
        }

        dataOutput.writeShort(0x0016);

        dataOutput.writeShort(0x0031);

        writeTerminator(dataOutput);
    }

    @Deprecated
    static void sendPreparedOperation(DataOutput dataOutput, InformixOperationType preparedOperationType) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        dataOutput.writeShort(0x0000);

        writePreparedOperationType(dataOutput, preparedOperationType);

        writeTerminator(dataOutput);
    }

    static void sendBegin(DataOutput dataOutput) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.BEGIN);

        writeTerminator(dataOutput);
    }

    static void sendCommit(DataOutput dataOutput) throws IOException {

        if (Boolean.FALSE) {

            writeMessageType(dataOutput, InformixMessageType.OPERATION);

            dataOutput.writeShort(0x0000);

            writePreparedOperationType(dataOutput, InformixOperationType.COMMIT);
        }
        else {
            writeMessageType(dataOutput, InformixMessageType.COMMIT);
        }

        writeTerminator(dataOutput);
    }

    static void sendFetchResultSet(DataOutput dataOutput, InformixColumnPreparedStatement preparedStatement) throws IOException {

        writeMessageType(dataOutput, InformixMessageType.OPERATION);

        writePreparedStatementIdentifier(dataOutput, preparedStatement);

        // max number of rows?
        dataOutput.writeShort(0x0064);

        dataOutput.writeShort(0x0001);

        dataOutput.writeShort(preparedStatement.getIdentifier());

        final List<PreparedColumn> columns = preparedStatement.getColumns();

        dataOutput.writeShort(columns.size());

        for (PreparedColumn column : columns) {

            dataOutput.writeShort(column.getDataType().getCode());

            dataOutput.writeShort(0x0000);

            dataOutput.writeShort(column.getNumRowBytes());
        }

        dataOutput.writeShort(0x0009);

        dataOutput.writeShort(0x0010);

        dataOutput.writeShort(0x0000);

        writeTerminator(dataOutput);
    }

    private static void writePreparedStatementIdentifier(DataOutput dataOutput, InformixPreparedStatement preparedStatement) throws IOException {

        final int identifier = preparedStatement.getIdentifier();

        if (identifier > DriverUtil.MAX_UNSIGNED_SHORT) {

            throw new IllegalStateException();
        }

        dataOutput.writeShort(identifier);
    }

    private static void writeMessageType(DataOutput dataOutput, InformixMessageType messageType) throws IOException {

        if (messageType.getDirection() != Direction.OUTBOUND) {

            throw new IllegalArgumentException();
        }

        dataOutput.writeShort(messageType.getCode());
    }

    private static void writeInformixDataType(DataOutput dataOutput, InformixDataType informixDataType) throws IOException {

        dataOutput.writeShort(informixDataType.getCode());
    }

    @Deprecated
    private static void writeExecuteType(DataOutput dataOutput, InformixExecuteType executeType) throws IOException {

        dataOutput.writeShort(executeType.getCode());
    }

    private static void writePreparedOperationType(DataOutput dataOutput, InformixOperationType preparedOperationType) throws IOException {

        dataOutput.writeShort(preparedOperationType.getCode());
    }

    private static void writeTerminator(DataOutput dataOutput) throws IOException {

        dataOutput.writeShort(TERMINATOR);
    }

    private static void writeKeyValueZeroTerminated(DataOutput dataOutput, String key, String value) throws IOException {

        writeLengthZeroTerminatedASCIIString(dataOutput, key);
        writeLengthZeroTerminatedASCIIString(dataOutput, value);
    }

    private static void writeKeyValue(DataOutput dataOutput, String key, String value) throws IOException {

        final int keyBytesWritten = writeLengthASCIIString(dataOutput, key);

        writeOnePad(dataOutput, keyBytesWritten);

        final int valueBytesWritten = writeLengthASCIIString(dataOutput, value);

        writeOnePad(dataOutput, valueBytesWritten);
    }

    private static int writeLengthZeroTerminatedASCIIString(DataOutput dataOutput, String string) throws IOException {

        final int bytesWritten = writeLengthASCIIString(dataOutput, string, 1);

        dataOutput.writeByte(0);

        return bytesWritten;
    }

    private static int writeLengthASCIIString(DataOutput dataOutput, String string) throws IOException {

        return writeLengthASCIIString(dataOutput, string, 0);
    }

    private static int writeLengthASCIIString(DataOutput dataOutput, String string, int additional) throws IOException {

        Objects.requireNonNull(dataOutput);
        Objects.requireNonNull(string);

        if (additional < 0) {

            throw new IllegalArgumentException();
        }

        final int stringLength = string.length();

        if (stringLength > DriverUtil.MAX_UNSIGNED_SHORT) {

            throw new IllegalArgumentException();
        }

        dataOutput.writeShort(stringLength + additional);

        DriverUtil.writeASCIIStringCharacters(dataOutput, string);

        return stringLength;
    }

    private static void writeOnePad(DataOutput dataOutput, int number) throws IOException {

        if ((number & 0x00000001) != 0) {

            dataOutput.writeByte(0);
        }
    }
}
